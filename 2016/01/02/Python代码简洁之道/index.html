

<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <script type="text/javascript" src="http://tajs.qq.com/stats?sId=44218032" charset="UTF-8"></script>
  <script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?7192fa361f5cabb11d8a22de41c1ba8f";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>
  
  <title>Python代码简洁之道 | Heriky</title>
  <meta name="author" content="Heriky">
  
  <meta name="description" content="在Python中，代码不是越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好。1行代码能实现的功能，决不写2行代码。请始终牢记，代码越少，开发效率越高。

如果你还没有接触过Python，强烈建议学习廖雪峰老师的教程。
一.代码风格1.切片的妙用12345678910111213141516171819202122# 奇数list(range(1,101)[0::2])#偶数list(range(0,100)[0::2])# 后10个数list(range(0,100)[-10:])# 使用切片实现reverse# 如果为负方向切片，则起始位置应比中指位置的索引大（从右向左）# 如果为正方向切片，则起始位置比终止位置小（从左向右）# 方向不同，则遍历的方向也不同，默认值也发生变化，不写时头尾变成尾头[1,2,3][::-1][1,2,3,4,5][-1:-4:-1][1,2,3,4,5][3::-1] #从索引3切到开头[1,2,3,4,5][:1:-1] # 从末尾切到索引1# 回文数def is_palindrome(n):    return str(n)  == str(n)[::-1]
 2.连续赋值方式 1234567891011# 可以使用如下的赋值方式,加不加括号效果一样a,b,c = 1,2,3a,b,c = (1,2,3)# 交换swap,使用元组的方式a,b = b,a for x,y,z in [(1,2,3),(4,5,6)]:   print(x,y,z)">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Python代码简洁之道"/>
  <meta property="og:site_name" content="Heriky"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/imgs/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="Heriky" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//libs.baidu.com/jquery/1.8.0/jquery.min.js"></script>
</head>


<body>
  <header><div>
		
			<div id="imglogo">
				<a href="/"><img src="/imgs/logo.png" alt="Heriky" title="Heriky"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name">Heriky</h1>
				<h2 class="blog-motto">no pains,no gains</h2>
			</div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li> <a href="/atom.xml">RSS</a> </li>
				</ul>
			</nav>			
</div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header class="article-info clearfix">
  <h1 itemprop="name">
	Python代码简洁之道
  </h1>
  <p class="article-author">By
    
      <a href="/about" title="Heriky">Heriky</a>
    </p>
  <p class="article-time">
    <time datetime="2016-01-02T12:08:49.000Z" itemprop="datePublished">2016-01-02</time>
    更新日期:<time datetime="2016-01-02T12:26:08.189Z" itemprop="dateModified">2016-01-02</time>
    
  </p>
</header>
    <div class="entry">
		
        <p>在Python中，代码不是越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好。1行代码能实现的功能，决不写2行代码。请始终牢记，代码越少，开发效率越高。</p>
<p><img src="http://i4.tietuku.com/94dd81a926d83cce.png" alt="Python"></p>
<p>如果你还没有接触过Python，强烈建议学习<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" title="极力推荐" target="_blank" rel="external">廖雪峰老师的教程</a>。</p>
<h2 id="u4E00-_u4EE3_u7801_u98CE_u683C"><a href="#u4E00-_u4EE3_u7801_u98CE_u683C" class="headerlink" title="一.代码风格"></a>一.代码风格</h2><p>1.<strong>切片的妙用</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 奇数</span></span><br><span class="line">list(range(<span class="number">1</span>,<span class="number">101</span>)[<span class="number">0</span>::<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#偶数</span></span><br><span class="line">list(range(<span class="number">0</span>,<span class="number">100</span>)[<span class="number">0</span>::<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后10个数</span></span><br><span class="line">list(range(<span class="number">0</span>,<span class="number">100</span>)[-<span class="number">10</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用切片实现reverse</span></span><br><span class="line"><span class="comment"># 如果为负方向切片，则起始位置应比中指位置的索引大（从右向左）</span></span><br><span class="line"><span class="comment"># 如果为正方向切片，则起始位置比终止位置小（从左向右）</span></span><br><span class="line"><span class="comment"># 方向不同，则遍历的方向也不同，默认值也发生变化，不写时头尾变成尾头</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>][::-<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>][-<span class="number">1</span>:-<span class="number">4</span>:-<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>][<span class="number">3</span>::-<span class="number">1</span>] <span class="comment">#从索引3切到开头</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>][:<span class="number">1</span>:-<span class="number">1</span>] <span class="comment"># 从末尾切到索引1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回文数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> str(n)  == str(n)[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p> 2.连续赋值方式<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 可以使用如下的赋值方式,加不加括号效果一样</span></span><br><span class="line">a,b,c = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">a,b,c = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交换swap,使用元组的方式</span></span><br><span class="line">a,b = b,a </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x,y,z <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)]:</span><br><span class="line">   print(x,y,z)</span><br></pre></td></tr></table></figure></p>
 <a id="more"></a>
<p> 3.统计<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">(ss)</span>:</span></span><br><span class="line">    d = &#123;&#125; </span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> ss:</span><br><span class="line">        d.setdefault(s,[]).append(s)</span><br><span class="line">    <span class="keyword">return</span> dict([(key,len(value)) <span class="keyword">for</span> key,value <span class="keyword">in</span> ss]) ;</span><br><span class="line">    <span class="comment"># 没有dict生成式，只有借助于列表生成元组列表，在dict转换成对象&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试获取，没有则添加，使用dict.get(key,default)进行优化</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> dd:</span><br><span class="line">    dd.setdefault(key) ; <span class="comment"># 有则获取，没有则添加后获取</span></span><br><span class="line">    dd.get(key,default) ; <span class="comment"># 没有则返回默认值</span></span><br></pre></td></tr></table></figure></p>
<p> 4.序列连接<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#与js和其他语言都不同，python中join是str的方法而不是list的方法</span></span><br><span class="line"><span class="comment"># 因此调用方向是相反的</span></span><br><span class="line"><span class="string">''</span>.join([])</span><br></pre></td></tr></table></figure></p>
<p> 5.dict合并与分割<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过两个list来创建dict，使用zip内建函数</span></span><br><span class="line">a = [<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">dict(zip(a,b)) </span><br><span class="line"><span class="comment"># 生成 &#123;'x':1,'y':2&#125;</span></span><br></pre></td></tr></table></figure></p>
<p> 5.x 使用zip来同时处理两个列表</p>
<p> zip的功能可以看做是将两个列表组合成一个dict，第一个列表表示key，第二为value<br> ，其实质是生成一个包含元组列表的迭代器<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">c = zip(a,b) //object 可迭代,也是个Iterator</span><br></pre></td></tr></table></figure></p>
<p> 6.列表生成式进阶</p>
<p> 使用列表生成式可以简单的代替filter，如果判断逻辑复杂了就用filter好了<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 条件列表,if条件紧接着for完成之后</span></span><br><span class="line">L1 = [<span class="string">'Hello'</span>, <span class="string">'World'</span>, <span class="number">18</span>, <span class="string">'Apple'</span>, <span class="keyword">None</span>] </span><br><span class="line">L2 = [x <span class="keyword">for</span> x <span class="keyword">in</span> L1 <span class="keyword">if</span> isinstance(x,str)]</span><br><span class="line">L3 = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">100</span>) <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求出指定范围内不含重复数字的自然数，例如121，112，都算含有重复数字</span></span><br><span class="line"><span class="comment"># 因为这里的判断逻辑其实不复杂，则使用列表推导式自带的条件判断即可</span></span><br><span class="line"></span><br><span class="line">[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1000</span>) <span class="keyword">if</span> max(Counter(str(x)).values()) == <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p> 7.Generator应用，<em>无限大的序列可以使用Generator来实现</em><br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 杨辉三角</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tr</span><span class="params">()</span>:</span></span><br><span class="line">    L = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> L</span><br><span class="line">            L = [<span class="number">1</span>]+[L[x]+L[x+<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> range(len(L)-<span class="number">1</span>)] +[<span class="number">1</span>]</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> tr():</span><br><span class="line">    print(t)</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器来获取素数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">_odd_iter</span><span class="params">()</span>:</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>  <span class="keyword">True</span>:</span><br><span class="line">        n = n+<span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_n</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x % n !=<span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    it = _odd_iter() <span class="comment"># 获得概念上的序列</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        n = next(it) <span class="comment"># 返回序列第一个数</span></span><br><span class="line">        yeild n</span><br><span class="line">        filter(filter_n(n),it) <span class="comment">#不要使用lambda(x:x%n&gt;0)，这里为n创建了一个闭包</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> primes():</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">100</span>:</span><br><span class="line">        print(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line"><span class="comment"># 对列表推导的扩展，使用generator</span></span><br><span class="line"><span class="comment"># 对于一个无限大的列表，很容易造成内存溢出</span></span><br><span class="line"><span class="comment"># 另一方面列表推导可以扩展成生成器，只要使用括号就行</span></span><br><span class="line"></span><br><span class="line">a = (x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10000000</span>))</span><br><span class="line"><span class="comment"># 这样只需要对generator进行for...in迭代就可</span></span><br></pre></td></tr></table></figure></p>
<p>8.高阶函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 利用map和reduce编写一个str2float函数，</span></span><br><span class="line"> <span class="comment"># 把字符串'123.456'转换成浮点数123.456：</span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">str2float</span><span class="params">(s)</span>:</span></span><br><span class="line">    it,fl = s.split(<span class="string">'.'</span>) <span class="comment">#分离整数部分和小数部分</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y:x*<span class="number">10</span>+y,map(int,it)</span><br><span class="line">            )+reduce(<span class="keyword">lambda</span> x,y:x*<span class="number">10</span>+y,map(int,fl)) / <span class="number">10</span>**len(fl)</span><br><span class="line">            </span><br><span class="line"><span class="comment"># 计算阶乘</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#懒惰的Python程序员</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">1</span> <span class="keyword">and</span> x * fact(x - <span class="number">1</span>) <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> fact(<span class="number">6</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#更懒惰的Python程序员</span></span><br><span class="line">f = <span class="keyword">lambda</span> x: x <span class="keyword">and</span> x * f(x - <span class="number">1</span>) <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> f(<span class="number">6</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#专家级Python程序员</span></span><br><span class="line"><span class="keyword">import</span> operator <span class="keyword">as</span> op</span><br><span class="line"><span class="keyword">import</span> functional <span class="keyword">as</span> f</span><br><span class="line">fact = <span class="keyword">lambda</span> x: f.foldl(op.mul, <span class="number">1</span>, xrange(<span class="number">2</span>, x + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">print</span> fact(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p> 9.合并字典<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> dict1 = &#123;<span class="string">'x'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">'y'</span>:[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]&#125;</span><br><span class="line"> dict2 = &#123;<span class="string">'m'</span>:[<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>],<span class="string">'n'</span>:[<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>]&#125;</span><br><span class="line"> <span class="comment"># 通过转换为元组列表</span></span><br><span class="line">dictx = dict(dict1.items()+dict2.items())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过关键字参数传入，活用关键字参数</span></span><br><span class="line">dictx = dict(dict1,**dict2) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 以上代码等价于</span></span><br><span class="line">dicty = dict1.copy()</span><br><span class="line">dicty.update(dict2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制一个dict使用</span></span><br><span class="line">dictc = dict.copy()</span><br><span class="line"><span class="comment"># 扩展一个dict使用</span></span><br><span class="line">dictb = dict.update(&#123;<span class="string">'x'</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<p> 10.关于dict<br> 字典的生成有多重方式，使用不同的方式会达到和其他类型数据结构千丝万缕的关系<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 1.使用类的方式或类实例</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    name = <span class="string">'zhagnsna'</span></span><br><span class="line">    age = <span class="string">'lisi'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,score)</span>:</span></span><br><span class="line">        self.score = score</span><br><span class="line">p = Person(<span class="number">90</span>)</span><br><span class="line">Person.__dict__ <span class="comment"># 除了打印类的属性，还把__init__,__doc__等打印出来</span></span><br><span class="line">p.__dict__ <span class="comment"># 只打印了&#123;'socre':90&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.列表元组</span></span><br><span class="line"><span class="comment"># 使用列表元组可以轻易连接dict和list，这样就可以使用list的一些特性操作dict</span></span><br><span class="line"><span class="comment"># 最显著的是使用使用列表生成器来操作dict</span></span><br><span class="line">a = &#123;<span class="string">'x'</span>:<span class="number">1</span>,<span class="string">'y'</span>:<span class="number">2</span>&#125;</span><br><span class="line">dict((key.upper(),value <span class="keyword">for</span> key,value <span class="keyword">in</span> a.items()))</span><br><span class="line"></span><br><span class="line">b = dict([(<span class="string">'x'</span>,<span class="number">1</span>),(<span class="string">'y'</span>,<span class="number">1</span>)]) <span class="comment"># 元组列表</span></span><br><span class="line">c = dict(((<span class="string">'x'</span>,<span class="number">1</span>),(<span class="string">'y'</span>,<span class="number">1</span>))) <span class="comment"># 元组元组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.使用key=value的形式</span></span><br><span class="line"><span class="comment"># 最显著的应用是对于继承了dict的子类，若子类中没有定义__init__就会调用</span></span><br><span class="line"><span class="comment"># dict的构造，因此可以使用这种赋值方式</span></span><br><span class="line">e = dict(<span class="string">'x'</span>=<span class="number">1</span>,<span class="string">'y'</span>=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p> 11.文件目录遍历</p>
<p>  调用方法：</p>
<blockquote>
<p>os.walk(top, topdown = True, onerror = None, followlinks = False)<br> 第一个参数是传入的初始目录名称，第二个参数是遍历方式，True表示自定向下遍历首先返回<br> 顶层目录下的文件和子目录，False表示自底向上遍历首先返回底部的文件和子目录。</p>
</blockquote>
<p> 返回结果：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> root,dirs,files <span class="keyword">in</span> os.walk(<span class="string">'D://'</span>)</span><br><span class="line"> </span><br><span class="line"> root：表示每次遍历过程中的父目录，dirs表示每次遍历中的父目录下的子目录列表，</span><br><span class="line"> files表示父目录下的文件列表，三个参数中若某项没有则返回为空</span><br><span class="line"> </span><br><span class="line"> 例如：</span><br><span class="line"> </span><br><span class="line">Root =  D:\Test dirs =  [<span class="string">'SubTest1'</span>, <span class="string">'SubTest2'</span>] files =  [<span class="string">'TEST DOCUMENT.docx'</span>, <span class="string">'TEST.txt'</span>]</span><br><span class="line"> </span><br><span class="line">Root =  D:\Test\SubTest1 dirs =  [<span class="string">'ThirdLayer'</span>] files =  [<span class="string">'TEST DOCUMENT1.docx'</span>, <span class="string">'TEST1.txt'</span>]</span><br><span class="line"> </span><br><span class="line">Root =  D:\Test\SubTest1\ThirdLayer dirs =  [] files =  [<span class="string">'TEST DOCUMENT L3.docx'</span>, <span class="string">'TEST L3.txt'</span>]</span><br><span class="line"> </span><br><span class="line">Root =  D:\Test\SubTest2 dirs =  [] files =  [<span class="string">'TEST DOCUMENT2.docx'</span>, <span class="string">'TEST2.txt'</span>]</span><br></pre></td></tr></table></figure>
<p> 12.字符串格式化formt方法</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">25</span></span><br><span class="line">name = <span class="string">'Caroline'</span></span><br><span class="line"> </span><br><span class="line">print(<span class="string">'&#123;0&#125; is &#123;1&#125; years old. '</span>.format(name, age)) <span class="comment">#输出参数</span></span><br><span class="line">print(<span class="string">'&#123;0&#125; is a girl. '</span>.format(name))</span><br><span class="line">print(<span class="string">'&#123;0:.3&#125; is a decimal. '</span>.format(<span class="number">1</span>/<span class="number">3</span>)) <span class="comment">#小数点后三位</span></span><br><span class="line">print(<span class="string">'&#123;0:_^11&#125; is a 11 length. '</span>.format(name)) <span class="comment">#使用_补齐空位</span></span><br><span class="line">print(<span class="string">'&#123;first&#125; is as &#123;second&#125;. '</span>.format(first=name, second=<span class="string">'Wendy'</span>)) <span class="comment">#别名替换</span></span><br><span class="line">print(<span class="string">'My name is &#123;0.name&#125;'</span>.format(os)) <span class="comment">#调用方法</span></span><br><span class="line">print(<span class="string">'My name is &#123;0:8&#125;.'</span>.format(<span class="string">'Fred'</span>)) <span class="comment">#指定宽度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt; 表示字符左对齐，默认补空格，&gt; 右对齐， ^ 居中对齐</span></span><br><span class="line"><span class="string">"[&#123;0:*&lt;10&#125;], [&#123;0:*^10&#125;], [&#123;0:*&gt;10&#125;]"</span>.format(<span class="string">"a"</span>) <span class="comment"># 左中右对其</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些取值的格式化</span></span><br><span class="line"><span class="string">'This is &#123;0[a]&#125;'</span>.format(dict(a = <span class="number">10</span>,b = <span class="number">20</span>)) <span class="comment"># 输出 This is 10</span></span><br><span class="line"> <span class="string">'This is &#123;0[5]&#125;'</span>.format(range(<span class="number">10</span>)) <span class="comment"># This is 5'</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 可以直接格式化日期！！</span></span><br><span class="line"> <span class="string">"Today is &#123;0:%Y-%M&#125;"</span>.format(datetime.now()) </span><br><span class="line"> <span class="string">"Today is: &#123;0:%a %b %d %H:%M:%S %Y&#125;"</span>.format(datetime.now())</span><br></pre></td></tr></table></figure>
<p> 输出：</p>
<pre><code>Caroline is 25 years old. 
Caroline is a girl. 
0.333 is a decimal. 
_Caroline__ is a 11 length. 
Caroline is as Wendy. 
My name is out.txt
My name is Fred    .
</code></pre><p> 使用format方法可以在数学计算中实现保留小数点的功能：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">(<span class="string">'&#123;0:.3&#125;'</span>.format(sum(L) / len(L)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用python内置的求平均值函数</span></span><br><span class="line"> <span class="keyword">from</span> statistics <span class="keyword">import</span> mean</span><br><span class="line"> mean(L)</span><br></pre></td></tr></table></figure></p>
<h2 id="u4E8C-_u6E29_u6545_u77E5_u65B0"><a href="#u4E8C-_u6E29_u6545_u77E5_u65B0" class="headerlink" title="二.温故知新"></a>二.温故知新</h2><p>1.动态类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.name</span><br><span class="line">    </span><br><span class="line">p = Person()</span><br><span class="line">p.name = <span class="string">'xx'</span> </span><br><span class="line">p.get_name = get_name <span class="comment"># 错误，无法将self正确传入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line">p.get_name = MethodType(get_name,p) <span class="comment">#使用MethodType包装成对象</span></span><br><span class="line"><span class="comment"># 给一个实例绑定对象和属性，对另一个实例不影响，这类似于原型链继承</span></span><br><span class="line"><span class="comment"># 若在类（原型链）上添加属性和方法，则都可以访问</span></span><br></pre></td></tr></table></figure>
<p>2.错误类型</p>
<ul>
<li>Exception</li>
<li>ValueError</li>
<li>KeyError</li>
<li>AttributeError</li>
<li>StopIteration</li>
</ul>
<p>3.Enum枚举类型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Enum关键字动态创建一个枚举类Month,其成员通过tuple初始化，value从1开始</span></span><br><span class="line">Month = Enum(<span class="string">'Month'</span>,(<span class="string">'Jan'</span>,<span class="string">'Feb'</span>,<span class="string">'Mar'</span>,<span class="string">'Apr'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 精确控制value，使用Enum生成枚举类</span></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum,unique</span><br><span class="line"><span class="decorator">@unique</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekday</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    Sun = <span class="number">0</span>  <span class="comment"># 可以精确控制value值</span></span><br><span class="line">    Feb = <span class="number">1</span></span><br><span class="line">    Wed = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enum 和 Month关系</span></span><br><span class="line">type(Enum) <span class="comment"># &lt;class 'enum.EnumMeta'&gt;</span></span><br><span class="line">type(Month) <span class="comment"># &lt;class 'enum.EnumMeta'&gt;</span></span><br><span class="line"></span><br><span class="line">isinstance(Month.Jan,Month) <span class="comment"># True</span></span><br><span class="line">isinstance(Month.Jan,Enum)  <span class="comment"># True</span></span><br><span class="line">isinstance(Month,Enum) <span class="comment"># false</span></span><br><span class="line">issubclass(Month,Enum) <span class="comment"># true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>结论</strong>:</p>
<ul>
<li>Enum和Month都是类，而且都是枚举类，Month通过继承Enum来变成枚举类</li>
<li>枚举类中每个枚举值都是枚举类的实例，因此Month.Jan是Month的实例也是Enum实例</li>
<li>枚举类中定义的都是实例，而不是属性</li>
</ul>
<h3 id="4-__u6587_u4EF6_28File-like-object_29_u64CD_u4F5C_u9AD8_u7EA7_u7279_u6027"><a href="#4-__u6587_u4EF6_28File-like-object_29_u64CD_u4F5C_u9AD8_u7EA7_u7279_u6027" class="headerlink" title="4. 文件(File-like-object)操作高级特性"></a>4. 文件(File-like-object)操作高级特性</h3><p>1.对于一个文件，打开之后（通过rw），连续读写的时候会发生问题。究其原因，先写后读<br>是读不出任何数据的，在文件写操作之后文件指针处于文件尾部，此时再读，文件指针下一步<br>指向的是空内容。这个问题类似于java中list不能连续进行两次迭代一样。都是指针移动到<br>末尾引发的问题。解决方法：f.seek(0)重回文件头.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">f = BytesIO()</span><br><span class="line">f.write(<span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>)</span><br><span class="line">f.seek(<span class="number">0</span>) <span class="comment"># 如果不重置指针为0，会读不出</span></span><br><span class="line">print(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外通过StringIO初始化时指针并不移动到文件尾部</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">f = BytesIO(<span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>) <span class="comment"># 指针还在头部</span></span><br><span class="line">f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似的读写异常基本上都是文件指针的问题！！！</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u4E09-_u9AD8_u7EA7_u7279_u6027_28_u5143_u7C7B_uFF0CDuckType_uFF0Csuper_2Cmixin_29"><a href="#u4E09-_u9AD8_u7EA7_u7279_u6027_28_u5143_u7C7B_uFF0CDuckType_uFF0Csuper_2Cmixin_29" class="headerlink" title="三.高级特性(元类，DuckType，super,mixin)"></a>三.高级特性(元类，DuckType，super,mixin)</h2><h3 id="u7B2C_u4E00_u90E8_u5206__u9762_u5411_u5BF9_u8C61_u9AD8_u7EA7_u7279_u6027"><a href="#u7B2C_u4E00_u90E8_u5206__u9762_u5411_u5BF9_u8C61_u9AD8_u7EA7_u7279_u6027" class="headerlink" title="第一部分 面向对象高级特性"></a>第一部分 面向对象高级特性</h3><hr>
<h3 id="1-_u5B9A_u5236_u7C7B"><a href="#1-_u5B9A_u5236_u7C7B" class="headerlink" title="1.定制类"></a>1.定制类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a = <span class="number">1</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span>(<span class="string">'this is a object of fib'</span>)</span><br><span class="line">    __repr__ = __str__</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用iter()方法可以获得迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对迭代器进行迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b  =  self.b,  self.a + self.b</span><br><span class="line">        <span class="keyword">if</span> self.a&gt;<span class="number">1000</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="keyword">return</span> self.a</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用[ ]  的方式进行访问</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self,n)</span>:</span></span><br><span class="line">        a, b = <span class="number">1</span> ,<span class="number">1</span></span><br><span class="line">        <span class="comment"># 处理数组索引调用</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(n,int):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                a, b = b, a+b</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 处理切片调用</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(n, slice):</span><br><span class="line">            start = n.start  <span class="keyword">or</span> <span class="number">0</span> <span class="comment"># slice切片对象中的属性</span></span><br><span class="line">            stop = n.stop   <span class="comment"># step是必须传的，因为这里没有明确的长度</span></span><br><span class="line">            step = n.step <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">            L = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,stop,step):</span><br><span class="line">                L.append(a)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(step):</span><br><span class="line">                    a,b = b, a+b</span><br><span class="line">            <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理关键字数组式调用</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(n,str):</span><br><span class="line">            key = str(n)</span><br><span class="line">            <span class="keyword">if</span> hasattr(self,key):</span><br><span class="line">                <span class="keyword">return</span> self.key</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> AttributeError(<span class="string">'not exsit attribute "%s"'</span>%key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用[ ]的方式进行赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self,key,value)</span>:</span></span><br><span class="line">        setattr(self,key,value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当试图访问对象中 [不存在的属性] 时，会调用此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self,attr)</span>:</span> </span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">'score'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">99</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">'object has no attribute "%s"'</span>%attr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 任何情况下向对象添加属性方法时，都会调用__setattr__因此不要轻易改写这个方法</span></span><br><span class="line">    <span class="comment">#def __setattr__(self,key,value):</span></span><br><span class="line">    <span class="comment">#   print('set______')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用__call__和__getattr__来实现链式调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chain</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,path=<span class="string">''</span>)</span>:</span></span><br><span class="line">        self._path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self,path)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Chain(<span class="string">'%s/%s'</span>%(self._path,path))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,path)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Chain(<span class="string">'%s/%s'</span>%(self._path,path))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._path</span><br><span class="line">    __repr__ = __str__</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用凡是为 Chain().users('hk').repos</span></span><br><span class="line">    <span class="comment"># 结果是 /users/hk/repos</span></span><br></pre></td></tr></table></figure>
<hr>
<p>###2.元类###</p>
<ul>
<li>类在生成的时候都是需要依据元类的，平时在定义类的时候没有传入metaclass参数，实际上这个参数默认使用了系统提供的元类。 class Person(object)和class Person(object,metaclass=’系统默认的’)是等价的。当我们手动设定metaclass为自己定义的元类的时候，类的生成过程就可以被我们控制了,可以自定义一些属性，方法。</li>
<li>元类的查找是沿着继承链进行的，自身没有就去父类上找（多继承？）,最终找到object还没有的话就又使用系统提供的元类了</li>
<li><a href="/herf=&#39;http://blog.jobbole.com/21351/&#39;">参考文档</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同str，int一样type是创建类这个特殊对象的元类</span></span><br><span class="line"><span class="comment"># 创建每个对象都需要元类，type实际上是系统默认元类</span></span><br><span class="line"><span class="comment"># python中一切皆对象，type是他自身的对象 type(type) == type</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __new__方法在__init__之前调用，他是用来根据元类创建类对象的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,name,base,attr)</span>:</span></span><br><span class="line">        attrs = ((key,value) <span class="keyword">for</span> key,value <span class="keyword">in</span> attr.items() <span class="keyword">if</span> <span class="keyword">not</span> key.startswith(<span class="string">'__'</span>))</span><br><span class="line">        upper_attrs = dict((key,value.upper()) <span class="keyword">for</span> key,value <span class="keyword">in</span> attrs)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls,name,base,upper_attrs)</span><br><span class="line">        <span class="comment">#return super(UpperMetaclass,cls).__new__(cls,name,base,upper_attrs)</span></span><br><span class="line">        <span class="comment"># 这里调用父类方法的方式比较特殊，因为把cls传了两边，这是因为type.__new__的本身定义引起的歧义</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object,metaclass=UpperMetaclass)</span>:</span></span><br><span class="line">    bar = <span class="string">'hankang'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Hello,%s'</span>%self._name)</span><br></pre></td></tr></table></figure>
<p>元类的执行过程中会扫描当前class块中所有属性和方法，然后传入元类生成类对象,当前Person中<br>扫描到了bar ,<code>__init__</code>,<code>__del__</code>三个属性。<br>但由于由于上面元类过滤掉了<code>startswith(&#39;__&#39;)</code>的属性，因此<code>__init__</code>,  <strong>del</strong>这样的属性不会被传递<br>这样就相当于该类没有定义<code>__init__</code>方法，因此这里看起来定义了<code>__init__方法，并且
不传递参数就会出错，实际上这里</code>_<em>init</em>`_方法被过滤，使用p = Person()就可以生成对象了</p>
<hr>
<p>###3.super调用方法###</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#子类调用父类方法，途径有2中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'my name is %s'</span>%self._name) </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        <span class="comment">#这里必须显式调用父类构造</span></span><br><span class="line">        <span class="comment"># 方法一，通过 类名.method(*param)</span></span><br><span class="line">        <span class="comment"># 方法二，通过 super</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Person.__init__(self,name) # 第一种方法</span></span><br><span class="line">        super(Stu,self).__init__(name) <span class="comment">#第二种方法</span></span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Stu,self).say()</span><br><span class="line">        print(<span class="string">'my age is %s'</span>%self._age) <span class="comment"># super的方式调用父类方法</span></span><br></pre></td></tr></table></figure>
<p>建议使用super的方式调用父类方法，因为<a href="http://blog.163.com/wangbo_tester/blog/static/128067921200981741646428/" target="_blank" rel="external">参考文档</a></p>
<hr>
<h3 id="4-_u5173_u4E8EPython_u7EE7_u627F_u7684_u7279_u6027"><a href="#4-_u5173_u4E8EPython_u7EE7_u627F_u7684_u7279_u6027" class="headerlink" title="4.关于Python继承的特性"></a><span style="color:red">4.关于Python继承的特性</span></h3><p><strong> (1) 继承链中构造函数的执行 </strong></p>
<p>这一条比较重要，因为这里的调用过程与静态函数有相当大的不同。</p>
<p>java,c#等静态语言，面向对象比较严格，继承链中要想获得子类实例必须先默认生成父类实例。因此默认情况下，子类会调用父类的无参构造方法，若父类构造传入了参数，则必须在子类显式调用此方法。<br>即若父类的含参构造覆盖了无参构造，那么必须在子类中显式调用父类的这个构造，<br>因为在<code>静态语言中</code>子类的实例化之前必须先实例化父类。</p>
<p>但是，Python这种动态语言中并不遵循这一条，子类实例化得到对象之前<strong>并不需要<br>产生父类的实例化对象</strong>，因为Python中类属于鸭子类型，使用的过程中他并不强调父类，也不强调在继承链中的位置，仅仅看重的是对象当前所拥有的行为！！</p>
<p>因此，在我看来，Python中的继承并非严格意义上的继承（因为他在没有老爸的实例的情况下也可以生出儿子的实例），<br>其实质是：当子类需要某个属性时(属性和方法)会从自身和继承链上查找。<br>自身有则直接调用，没有则从继承链中查找，若查找到则把继承链上的属性方法拉到子类本身上来执行，<br>即将父类的方法变成自己的。俗话说，父类中的方法和属性就是个备胎，我没有的时候就从父类上偷，把这些变成我自己的，<br>继承父类就可以使用父类来描述子类的行为。</p>
<p>下面的例子说明java和python中继承的区别：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stu s = <span class="keyword">new</span> Stu(<span class="string">"lisi"</span>) ;</span><br><span class="line">        s.say();  <span class="comment">//  输出zhangsan</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>  String name ;</span><br><span class="line">    <span class="keyword">private</span> String nn ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"zhagnsan"</span> ;</span><br><span class="line">        <span class="keyword">this</span>.nn = name ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.name = name ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在java中的继承是一种更严谨的继承，符合人的思维逻辑，在儿子出生之前老爸必须先出生。<br>因此在子类的构造方法中第一句就需要调用父类的构造方法来建立父类实例，默认情况下<br>调用父类无参数构造super()，因为java中的多态是基于类型的，在多态转换是子类实例转换为父类<br>，要求父类实例是已经存在的，因此才必须在子类构造中调用父类构造器，这样在生成子类对象的<br>同时也生成了父类对象，以便于多态的实现。而且即使子类继承了父类的方法，子类也不会将这些方法<br>据为己有，这些方法仍属于父类，即使使用子类实例来调用这些继承来的方法，其中间<br>引用的属性还是父类的属性。所以以上调用s.say()时仍然使用的是父类中的name属性。</p>
<p>python因为多态的表现行为不同要求继承规则也完全不同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = <span class="string">'zhangsan'</span></span><br><span class="line">        self.nn = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        </span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">s = Stu(<span class="string">'lisi'</span>) </span><br><span class="line">s.say() <span class="comment"># 输出lisi</span></span><br></pre></td></tr></table></figure>
<p>可以看出，在这里子类调用了从父类继承的方法，期间self.name竟然不是父类中的赋值’zhangsan’<br>而是子类中的赋值’lisi’。</p>
<p>究其原因，Python在继承过程中因为’DuckType’的关系，在使用过程中并不强调继承链，只<br>强调行为，因此继承中只是继承了行为，即把父类中的行为偷过来作为自己的行为，所以这里<br>self.name当然打印子类自己的name属性。</p>
<p>因此，构造方法的调用规则是这样的：</p>
<ul>
<li><p>python中如果子类有自己的构造函数，不会自动调用父类的构造函数，如果需要用到父类的构造函数，则需要在子类的构造函数中手动显式的调用。<br>以此来初始化子类中的属性。</p>
</li>
<li><p>如果子类没有自己的构造函数，则会直接从父类<strong>继承构造函数</strong>，继承构造函数并调用，结果值生成了子类的实例<br>和实例上的属性，父类实例并没有生成（并不是说调用了父类构造就生成了父类的实例，因为这里实际上子类通过继承将父类的构造当成自己的构造来用），这在单继承（一个子类只从一个父类派生）中没有任何理解上的问题。<br>但是在多继承中存在继承哪一个父类的构造函数的问题</p>
</li>
</ul>
<ul>
<li><p>多继承中遵循就近原则。子类从多个父类派生，而子类又没有自己的构造函数时，</p>
<ul>
<li><p>按顺序继承，哪个父类在最前面且它又有自己的构造函数，就继承它的构造函数；</p>
</li>
<li><p>如果最前面第一个父类没有构造函数，则继承第2个的构造函数，第2个没有的话，再往后找，以此类推。</p>
</li>
</ul>
</li>
</ul>
<p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(A,B,C)</span></span></span><br></pre></td></tr></table></figure></p>
<p>D类中有自己的构造则用自己的，没有则从父类上继承，若父类A上有则拿来用，没有则继续<br>从B上找，以此类推。实际上python多继承中如果有重名方法，调用时也是按照这个规则<br>进行查找，即就近原则。 </p>
<p><strong>总结</strong><br>说这么多其实就一句话：在python中使用类实例的属性或方法时，本身有则直接使用，本身<br>没有则直接从父类中拉取，其余并没有什么限制,因为甚至子类能继承父类的<strong>attr私有属性，<br>继承了属性_Base</strong>private。</p>
<h3 id="5-Mixin__u5B9E_u73B0_u591A_u7EE7_u627F_u6216_u63A5_u53E3_u529F_u80FD"><a href="#5-Mixin__u5B9E_u73B0_u591A_u7EE7_u627F_u6216_u63A5_u53E3_u529F_u80FD" class="headerlink" title="5.Mixin 实现多继承或接口功能"></a>5.Mixin 实现多继承或接口功能</h3><p>MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，<br><code>我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</code><br>在python中通过多重继承的方式来实现mixin，但是mixin与多重继承时有区别的，举个栗子：</p>
<p><strong> 多重继承： </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        this.name = name</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,age)</span>:</span></span><br><span class="line">        this.age = age</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,score)</span>:</span></span><br><span class="line">       super().__init__(name) <span class="comment"># 根据mro理论，这里实际上调用A中的__init__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所谓多继承，是有可能子类继承到父类的相关属性或者使用父类的构造器。</span></span><br><span class="line"><span class="comment"># 而mixin要求的是分离。</span></span><br></pre></td></tr></table></figure></p>
<p><strong> Mixin </strong><br>mixin虽然已多继承的方式出现，但是表达的功能却完全不同，这个类似于java中的接口。<br>举个栗子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TagMixin</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_tag</span><span class="params">(self, tag_id)</span>:</span></span><br><span class="line">        sql = (<span class="string">'insert into target_tagged'</span></span><br><span class="line">               <span class="string">' (target_id, target_kind, tag_id, creation_time) '</span></span><br><span class="line">               <span class="string">'values (?, ?, ?, CURRENT_TIMESTAMP)'</span>)</span><br><span class="line">        params = (self.ident, self.kind, tag_id)</span><br><span class="line">        storage.execute(sql, params)</span><br><span class="line">        storage.commit()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_tags</span><span class="params">(self)</span>:</span></span><br><span class="line">        sql = (<span class="string">'select tag_id, creation_time from target_tagged '</span></span><br><span class="line">               <span class="string">'where target_id = ? and target_kind = ?'</span>)</span><br><span class="line">        params = (self.ident, self.kind)</span><br><span class="line">        cursor = storage.execute(sql, params)</span><br><span class="line">        <span class="keyword">return</span> cursor.fetchall()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span><span class="params">(Model, TagMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    kind = <span class="number">1001</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ident, title)</span>:</span></span><br><span class="line">        self.ident = ident</span><br><span class="line">        self.title = title</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Post(%r, %r)'</span> % (self.ident, self.title)</span><br></pre></td></tr></table></figure></p>
<p>mixin要求：</p>
<ul>
<li>类是单一职责的</li>
<li><p>TagMixin 类对宿主类（Post）一无所知，除了要求宿主类有 ident 和 kind 这两个属性（等价于 Java 中要求宿主类实现 Entity 接口）<strong>宿主类的主体逻辑不会因为去掉 TagMixin 而受到影响</strong>，同时也不存在超类方法调用（super）以避免引入 MRO 查找顺序问题</p>
<p>所以这样比 Java 中的组合模式实现方式更加简洁。同时因为使用得当，钻石调用、MRO 查找顺序等多重继承的弊病也没有被踩到。<br>当然，这种 Duck Type 的设计也比显式的接口约束对开发者有更高的要求，要求代码中无 interface 而开发者脑海中有清晰的 interface。 </p>
</li>
</ul>
<h3 id="6-_u518D_u8C08super_uFF0C_u6DF1_u5165_u7406_u89E3super_u548Cmro"><a href="#6-_u518D_u8C08super_uFF0C_u6DF1_u5165_u7406_u89E3super_u548Cmro" class="headerlink" title="6.再谈super，深入理解super和mro"></a>6.再谈super，深入理解super和mro</h3><p>一看到super通常就会想到父类，类似java中<code>super().method</code>，但是在python中：</p>
<p><strong>super实际上指的并不是父类，而是MRO中下一个类！！</strong></p>
<p><strong>super实际上指的并不是父类，而是MRO中下一个类！！</strong></p>
<p><strong>super实际上指的并不是父类，而是MRO中下一个类！！</strong></p>
<p>重要的话要说三遍。MRO，全名Method Resolution Order，表示的是python在继承机制下调用<br>查找调用方法的顺序。而super函数实际上只是做了一件事情，那就是MRO序列中下一个类，super<br>方法的实质：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">super</span><span class="params">(cls,inst)</span>:</span></span><br><span class="line">    mro = inst.__class__.__mro__  <span class="comment"># inst负责生成mro的list</span></span><br><span class="line">    <span class="keyword">return</span> mro[mro.index(cls)+<span class="number">1</span>]  <span class="comment"># 2. 通过 cls 定位当前 MRO 中的 index, 并返回 mro[index + 1]</span></span><br></pre></td></tr></table></figure>
<p>举个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'This is root'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Root)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'enter A'</span>)</span><br><span class="line">        super().__init__() <span class="comment"># 在python3中对super(self.__class__,self) 的简写，实际上通过默认参数传递了</span></span><br><span class="line">        print(<span class="string">'leave A'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Root)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span>  <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'enter B'</span>)</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'leave B'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">d = C() </span><br><span class="line"></span><br><span class="line">print(d.__class__.__mro__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># super并不是父类，super指定是在MRO中下一个类</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m_super</span><span class="params">(cls,inst)</span>:</span></span><br><span class="line">    mro = inst.__class__.__mro__ <span class="comment"># 这里之所以不直接用cls，而是用inst.__class__是因为这里要保证有个实例</span></span><br><span class="line">    <span class="keyword">return</span> mro[mro.index(cls)+<span class="number">1</span>] <span class="comment"># 从mro序列中定位当前类的位置，然后加1，得到下一个类，返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#MRO 的顺序原则：基类永远出现在派生类后面，如果多继承，则基类的相对顺序不变</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u7B2C_u4E8C_u90E8_u5206__u8BED_u8A00_u7279_u6027_u8FDB_u9636"><a href="#u7B2C_u4E8C_u90E8_u5206__u8BED_u8A00_u7279_u6027_u8FDB_u9636" class="headerlink" title="第二部分 语言特性进阶"></a>第二部分 语言特性进阶</h2><p>一.上下文管理器</p>
<p>上下文管理器被with声明所激活，这个API涉及到两个方法。</p>
<ol>
<li><code>__enter__</code>方法，当执行流进入with代码块时，<code>__enter__</code>方法将执行。并且它将返回一个可供上下文使用的对象。</li>
<li>当执行流离开with代码块时，<code>__exit__</code>方法被调用，它将清理被使用的资源。</li>
</ol>
<p>利用@contextmanager装饰器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="decorator">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(label)</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'&#123;&#125;: &#123;&#125;'</span>.format(label, end - start))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> demo(<span class="string">'counting'</span>):</span><br><span class="line">    n = <span class="number">10000000</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># counting: 1.32399988174</span></span><br></pre></td></tr></table></figure></p>
<p>看上面这个例子，函数中yield之前的所有代码都类似于上下文管理器中<code>__enter__</code>方法的内容。而yield之后的所有代码都如<code>__exit__</code>方法的内容。如果执行过程中发生了异常，则会在yield语句触发。</p>

    </div>
    <footer>
        
  
  <div class="categories">
    <a href="/categories/Python/">Python</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/Python/">Python</a>
  </div>

		<div class="bdsharebuttonbox">
	<a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
	<a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a>
	<a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a>
	<a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="bds_more" data-cmd="more"></a>
	<a href="#" class="bds_count" data-cmd="count"></a>
</div>
<script>
window._bd_share_config=
{
	"common":{
		"bdSnsKey":{},
		"bdText":"",
		"bdMini":"2",
		"bdMiniList":false,
		"bdPic":"",
		"bdStyle":"0",
		"bdSize":"24"
	},
	"share":{},
	"image":{
		"viewList":["qzone","tsina","tqq","renren","weixin","fbook","twi"],
		"viewText":"分享到：",
		"viewSize":"24"
	},
	"selectShare":{
		"bdContainerClass":null,
		"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin","fbook","twi"]
	}
};
with(document)0[
	(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)
];
</script>    
        <div class="clearfix"></div>
    </footer>
  </div>
</article>

 <nav id="pagination" >
    
    
    <a href="/2016/01/02/Python装X指南/" class="alignright next" title="Python装X指南">Python装X指南</a>
    
    <div class="clearfix"></div>
</nav>



	
	<section id="comment">
		<!-- 多说评论框 start -->
		<div class="ds-thread" data-thread-key="2016/01/02/Python代码简洁之道/" data-title="Python代码简洁之道" data-url="/about/2016/01/02/Python代码简洁之道/"></div>
		<!-- 多说评论框 end -->
		<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		<script type="text/javascript">
		var duoshuoQuery = {short_name:"ihankang"};
		(function() {
			var ds = document.createElement('script');
			ds.type = 'text/javascript';ds.async = true;
			ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
			ds.charset = 'UTF-8';
			(document.getElementsByTagName('head')[0] 
			 || document.getElementsByTagName('body')[0]).appendChild(ds);
		})();
		</script>
		<!-- 多说公共JS代码 end -->
	</section>
	
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:/about">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Python/">Python</a><small>2</small></li>
  
    <li><a href="/categories/test/">test</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/Python/" style="font-size: 20px;">Python</a> <a href="/tags/测试/" style="font-size: 10px;">测试</a>
  </div>
</div>


  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://ihankang.com" title="HK's website" target="_blank">Hk</a></li>
</ul>
</div>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer"><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hi,This my blog powered by Hexo and  Concise theme. <br/>
			You can download this theme on github.</p>
	</section>
	 
	<div class="social-font clearfix">
		
		<a href="http://weibo.com/5744492117" target="_blank" title="weibo"></a>
		
		
		
		<a href="https://github.com/heriky" target="_blank" title="github"></a>
		
		
		
		
		<a href="mailto:744324414@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/huangjunhui/concise" target="_blank" title="Concise">Concise</a> © 2016 
		
		<a href="/about/about" target="_blank" title="Heriky">Heriky</a>
		
		</p>
</div>
</footer>
  <script src="//libs.baidu.com/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/counter.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<div id="totop" style="position:fixed;bottom:100px;right:10px;cursor: pointer;">
<a title="返回顶部"><img src="/imgs/scrollup.png"/></a>
</div>
<script src="/js/totop.js"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>


